# Intro to AD authentication
Lab to cover the basics of NTLM and Kerberos, and enumeration via crackmapexec

Attacks:
 - PTH
 - ASREProasting
 - Kerberoasting

Tooling - Linux
 - crackmapexe
 - impacket
 - smbclient
 - evil-winrm

Tooling - Windows
 - Rubeus
 - Invoke-TheHash

# NTLM
## Authentication flow
1. User uses domain credentials to authenticate
2. client machine sends the auth request containing the domain name and username
3. Server send a challenge
4. Client encrypts the challenge with the hash of the user's password as a key. (The hash is NT / RC4)
5. Server sends the domain name, username, challenge and response to the domain controller.
6. The domain controller validates everything and send the response to the server, allowing the authentication.

If this is on a local machine it will check the SAM file instead of checking against a domain controller.

## Hash Structure
Made up of 2 parts the LM:NT. Most of the time you will see only the NT version. If LM is set to `AAD3B435B51404EEAAD3B435B51404EE` it means that it is not being used. ( NT("") )

## Pass the Hash
If the attack has the user's hashed password they can still authenticate as if they know the plain text.

Instead of starting the authentication flow at step 1 they can start at step 4.

This is useful as windows will store the NTLM hash of user's within the SAM file, meaning if you can dump the hashes on a windows box you dont need to crack them in order to impersonate that user.

## Preventions
Windows will not store hashed passwords of length 16 or greater.

You could also just disable NTLM and use only kerberos.

# Kerberos (yucky)
## Authentication flow
1. [KRB_AS_REQ] -> User to KDC (DC) : The user send a timestamp of the user's hash, username, Service Principal Name (SPN) of the krbtgt and a nonce generated by the user to the KDC
2. [KRB_AS_REP] -> KDC to User : The KDC replies with a Ticket Granting Ticket (TGT) (Structure will be shown further down), a Session key and a user nonce.
3. [KRB_TGS_REQ] -> User to KDC : The user sends the TGT from step 2, username and timestamp encrypted with the Session key, the SPN of the requested service and a nonce.
4. [KRB_TGS_REP] -> KDC to User : The KDC replies with the Username, Ticket Granting Service (TGS) (Structure will be shown further down) and encrypted data with the session key (The Expiration date of teh TGS, User nonce and service session key)
5. [KRB_AP_REQ] -> User to Service : User sends the TGS and an encrypted username and timestamp.

## TGT Structure
The TGT is built of the Username, Session key, expiration date of the TGT and the PAC, which is signed by the KDC.

## TGS Structure
TGS is built from the service session key, Username, Expirateion date of the TGS and the PAC, signed by the KDC.

## Attacks: ASREProast
There is a flag called `DONT_REQ_PREAUTH` when creating a user account. If this flag is set you can request a TGT without needing to know the user's password.

This will give you a TGS that you can crack offline using hashcat. (not johntheripper, no one likes using that tool)

## Attacks: Kerberoasting
This attack is where you request TGSs from the KDC that are associated with service accounts, with the goal of cracking these tickets offline.

To do this attack you need valid domain credentials.

# Provisioning the Lab
Read the readme to set up your machine. Then run
```
ansible-playbook -i inventory.ini auth.yml
```
# Lab Notes
Username list:
```
k.malone
d.schrute
j.halpert
```

Hash list:
```
9480f234e713cf0dd846f5b006c5ea6e
```